## TODO List

### Immediate TODO's

 - Type checking - the exploration is real
 - Integers of smaller sizes don't seem to work
 - Enum values need to have the same type, and the value can be left out
 - Improve error messages!!!
 - Figure out the situation with different types of identifiers
 - What's the overloading situation? Complicated by planned ability to inject code into global/module scope
 - Structs and enums should not capture variable identifiers from local scope
 - Code gen

### Notes
 - Probably need to differentiate the concept of typechecking
   - local matching of types
   - constraints by directives, constant checking, etc.
   - transitivity
 - Differentiate synthetic flag: polymorphic, inferred, internal, computed
 - Declarations introduce a new scope for recursion's sake.
   Doesn't make much sense when declaring a struct's field or enum value though
   Typechecking might take care of that?
 - Default arguments can use other arguments.
   This needs to be checked for circular definitions.
   Polymorphism will also require this
 - Operator typechecking will be totally different once overloading is added
 - Deduplicating types
   pros:
    - less work when comparing types
   cons:
    - hard to retain source information


### Misc TODO's

 - Create general allocator interface (? maybe just make it more uniform ?)
   For example, to supply to array_add
 - Make an array_trim
 - Allow suffixes on number literals for more control without requiring more type annotations (f and u for float and unsigned)
 - Cleanup memory leaks in parsing
 - Put newline on errors at the end of file that doesn't end in a newline
 - Other escape sequences in strings (such as \UXXXXXX)
 - Improve error reporting
 - break keyword

### Needed to be a serious language

 - Polymorphism
   - Scopes may need to change a bit
 - FFI
 - intrinsics

### Other TODO's

 - built-in array type, string type
 - vector types (SIMD)
 - switch statements, #complete, enum_flags
 - #eval, #if, #assert, #text (return string to be spliced in)
 - struct literals
 - default initialization
 - cast/transmute
 - size_of, type_of, etc.
 - defer
 - goto - yes, really

### Ideas

 - Group types of AST's in memory? e.g. maybe all identifiers, or all declarations?
 - Calling convention abstraction
 - Stack inspection
 - Stack-like context instead of thread-locals
   (using a dedicated register/additional function parameter)
 - Allocator concept - anything implementing an allocator has aliasing rules
   - built-in stack allocator that uses stack pointer (instead of alloca)
 - Manual aliasing annotations
 - C# style properties...
   I'm somewhat hesitant, but they could be used to implement tagged pointers, relative pointers, SOA at user level (along with #text)
   Also, arrays that share a count (backing fields share count)
 - Custom casts - probably only explicit?
   what advantage does an explicit cast have over a function call?
   consider pros/cons of implicit casts
     - saves typing
     - ? tool for abstraction ?
     - bad when it does something unexpected
       - loss of information
       - side-effects (state or perf)
       - not conceptually similar types
 - #run -- with access to the compiler as a library
 - macro system that automatically invokes metaprograms
 - #pure functions, (at least optimization, anything else?)
   if a pure function has compile-time constants as arguments, it can be run at compile-time to produce the result
   The problem is when the result is potentially large. Either make evaluation only explicit, or provide a switch to disable this.
   If the compiler could reason about the costs, decision could be made automatically, when desired
 - #placeholder, a forward-declaration for things that will be generated by a metaprogram. Allows better errors and documentation
 - bool1, automatically compressed when in an array or adjacent in a struct. Or would C# properties be good enough?
   The problem with bool1 is: how would it interact with code that uses size_of e.g. allocators.
   Similar to SOA: the size of multiple things is smaller than the size of 1 thing multiplied by the number of things
 - for-else like python. Use case: instead of loop, set flag and break, check flag
 - no overloading, except using overload keyword. Require a placeholder
   Except overloading is a form of polymorphism, want it to be open rather than closed
 - python-like generators. Need to be type-safe though, generator structs need to be accessible
   Perhaps #generator takes a function which can yield, and produces a function and a type, after multiple return values is implemented
 - The ability to return l-values is probably good...
   What are the real disadvantages of references? -- intent, null, reassign space
   If assignment can be overridden, it is possible to implement in userland
   override assignment probably needed to implement relative pointers, etc by user


# lvalue/rvalue

It seems like passing lvalues would be useful, at least for implementing new kinds of storage mechanisms (SOA, relative pointer, etc)
However, I dislike references in C++, pointers are nice and explicit.
Note: this interacts with the aliasing situation

Implementation-wise
 - lvalues are pointers, auto-dereference
 - else in registers

 - memory    - can take address, or lift into registers
 - registers - can spill and take address


pointers/arrays
 - an rvalue that can be converted to an lvalue
 - conversely, you can only take the address of lvalues

spill rvalue to take address
lift lvalue into registers

pass-by-value
 - storage is ambiguous, can potentially be put into registers
 - copy-semantics, that is, changes will not affect original source

void blah() {

  // storage on stack, lvalue is pointer
  // Or storage in registers, lvalue refers to registers
  Thing t;

  t.blah; // could be register, or pointer

  // storage on stack, lvalue is pointer
  Thing &t = *stack_alloc(Thing, 1);

  t.blah; // pointer
}

// Some lvalues may be optimized into registers,
// But the only way to consistently pass/return lvalues is using pointers
