## TODO List

### Immediate TODO's

 - Type checking - the exploration is real
 - Figure out the situation with different types of identifiers
   It would be good to have a level of indirection so that declarations can be changed in one place
   Probably make a scope structure alongside the AST structure
 - What's the overloading situation? Complicated by planned ability to inject code into global/module scope
 - Structs and enums should not capture variable identifiers from local scope
 - Code gen

### Notes
 - Probably need to differentiate the concept of typechecking
   - local matching of types
   - constraints by directives, constant checking, etc.
   - transitivity
 - Differentiate synthetic flag: polymorphic, inferred, internal, computed
 - Declarations introduce a new scope for recursion's sake.
   Doesn't make much sense when declaring a struct's field or enum value though
   Typechecking might take care of that?
 - Default arguments can use other arguments.
   This needs to be checked for circular definitions.
   Polymorphism will also require this
 - Need to check for illegal double declarations
   Overloading and shadowing will be ok, but not double declaration in a single scope
 - Operator typechecking will be totally different once overloading is added
 - Deduplicating types
   pros:
    - less work when comparing types
   cons:
    - hard to retain source information


### Misc TODO's

 - Create general allocator interface (? maybe just make it more uniform ?)
   For example, to supply to array_add
 - Make an array_trim
 - Allow suffixes on number literals for more control without requiring more type annotations (f and u for float and unsigned)
 - Cleanup memory leaks in parsing
 - Put newline on errors at the end of file that doesn't end in a newline
 - Other escape sequences in strings (such as \UXXXXXX)
 - Improve error reporting
 - break keyword

### Needed to be a serious language

 - Polymorphism
   - Scopes may need to change a bit
 - FFI
 - intrinsics

### Other TODO's

 - built-in array type, string type
 - vector types (SIMD)
 - switch statements, #complete, enum_flags
 - #eval, #if, #assert, #text (return string to be spliced in)
 - struct literals
 - default initialization
 - cast/transmute
 - size_of, type_of, etc.
 - defer
 - goto - yes, really

### Ideas

 - Group types of AST's in memory? e.g. maybe all identifiers, or all declarations?
 - Calling convention abstraction
 - Stack inspection
 - Stack-like context instead of thread-locals
   (using a dedicated register/additional function parameter)
 - Allocator concept - anything implementing an allocator has aliasing rules
   - built-in stack allocator that uses stack pointer (instead of alloca)
 - Manual aliasing annotations
 - C# style properties...
   I'm somewhat hesitant, but they could be used to implement tagged pointers, relative pointers, SOA at user level (along with #text)
   Also, arrays that share a count (backing fields share count)
 - Custom casts - probably only explicit?
   what advantage does an explicit cast have over a function call?
   consider pros/cons of implicit casts
     - saves typing
     - ? tool for abstraction ?
     - bad when it does something unexpected
       - loss of information
       - side-effects (state or perf)
       - not conceptually similar types
 - #run -- with access to the compiler as a library
 - macro system that automatically invokes metaprograms
 - #pure functions, (at least optimization, anything else?)
   if a pure function has compile-time constants as arguments, it can be run at compile-time to produce the result
   The problem is when the result is potentially large. Either make evaluation only explicit, or provide a switch to disable this.
   If the compiler could reason about the costs, decision could be made automatically, when desired
 - #placeholder, a forward-declaration for things that will be generated by a metaprogram. Allows better errors and documentation
 - bool1, automatically compressed when in an array or adjacent in a struct. Or would C# properties be good enough?
   The problem with bool1 is: how would it interact with code that uses size_of e.g. allocators.
   Similar to SOA: the size of multiple things is smaller than the size of 1 thing multiplied by the number of things
 - for-else like python. Use case: instead of loop, set flag and break, check flag