// This is an EOL comment
/* This is a multi-line comment
*/
/*
	Comments
	/*
	 Can be nested
//	*/
*/

// Avoid undeclared identifier for now
u32 :: void;
s32 :: void;

derp :: 15;

ident : u32 = ((derp) + 10);
ident2 : s32 = ident+10*5;

// Avoid undeclared identifier for now
F :: void;
T1 :: void;
T2 :: void;
ret_type :: void;

bar :: 42;

func : F = (param1 : T1, param2 : T2) -> ret_type {};

id3 : u32 = ident*10+5;

id4 : u32 = 10 + 10 + 10 + 10 * 3 / 4;

id5 : u32 = func(bar)[10 + 10].member + 10;



func2 :: () -> u32 {};

true :: 1;
u8 :: void;
default_val :: 5;
ok := 33;

func3 :: () -> u32 {
    while true {
       func2(ident);
    }

	test_precedence :: void;

	test_precedence(10, 10)(ident)();

	var := 10;
	const :: 42;
	other : u32 = 0;

	blah := "Hello World!";

    if 10 + 10 {
        var + 42;
    }
    else {
        func(const);
    }

	inner_func :: (param1 : T1, parma2 := default_val) -> ret_type {
		ok;
	};

	if other-1 && !id3 || id4 && id5 {
		inner_func();
	}

	arr :: void;

	for arr {}
	for 0..9 {}
	for it : arr {}
	for it,it_index : arr {}
	for it : 0..9 {}
	for &it : arr {}
	for &it,it_index : arr {}

	// These are errors
	// for &it : 0..9 {}
	// for it,it_index : 0..9 {} 

	var += 31;
};


data_type :: struct {
    field1 : u32 = 0;
	const1 :: 10;
	field2 : s32 = -10;
	const2 :: 22;
	field3 : u8;
	const3 : s32 : 22;
};

thing :: enum {
	const1 :: 1;
	const2;
	const3 :: 3;
};

Link :: struct {
	next : &Link;
	data : &data_type;
};

get_last :: (head : &Link) -> u32 {
	while(head.next) {
		head = head.next;
	}
	return *head.data;
};

Context :: struct {};

callback_type :: (ctx : &Context, param : s32, param : s32) -> void;
